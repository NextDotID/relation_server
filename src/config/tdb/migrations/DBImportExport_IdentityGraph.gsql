CREATE GRAPH IdentityGraph (Identities, Proof_Forward, Proof_Backward, Contracts, Hold_Identity, Hold_Contract, Resolve, Reverse_Resolve, Resolve_Contract, Reverse_Resolve_Contract, Relation_Unique_TX, Relation_TX, Social_Feed)

USE GRAPH IdentityGraph

CREATE OR REPLACE QUERY delete_vertex_and_edge(VERTEX<Identities> p, INT depth=10) FOR GRAPH IdentityGraph SYNTAX v2 {
  SetAccum<EDGE> @@edges;
  SetAccum<VERTEX> @@vertices;
  OrAccum @visited = FALSE;
  OrAccum @visited2 = FALSE;

  seed (Identities) = {p};
  WHILE(seed.size()>0) LIMIT depth DO
    SetAccum<VERTEX> @@pool;
    proof = SELECT v FROM seed:s1-((Proof_Forward>|<Proof_Forward|Proof_Backward>|<Proof_Backward):pf)-Identities:v-((Proof_Forward>|<Proof_Forward|Proof_Backward>|<Proof_Backward):pw)-seed:s2
           WHERE v.@visited == FALSE AND s1 == s2
           ACCUM @@edges += pf, @@edges += pw, @@vertices += v, v.@visited = TRUE
           POST-ACCUM @@pool += v;
    hold = SELECT v FROM seed-((Hold_Identity>|<Hold_Identity):e)-Identities:v
           WHERE v.@visited2 == FALSE
           ACCUM @@edges += e, @@vertices += v, v.@visited2 = TRUE
           POST-ACCUM @@pool += v;
    seed (Identities) = {@@pool};
  END;

  vertex2delete (Identities) = {@@vertices};
  contracts = SELECT v FROM vertex2delete-((Reverse_Resolve_Contract>|<Resolve_Contract):e)-Contracts:v ACCUM DELETE(e);
  contracts = SELECT v FROM vertex2delete-((Hold_Contract>):e)-Contracts:v ACCUM DELETE(e);
  resolved = SELECT v FROM vertex2delete-((Resolve>|<Reverse_Resolve):e)-Identities:v ACCUM DELETE(e);
  proof2delete = SELECT v FROM vertex2delete-((Proof_Forward>|<Proof_Forward|Proof_Backward>|<Proof_Backward|Hold_Identity>|<Hold_Identity):e)-Identities:v ACCUM DELETE(e);
  result = SELECT v FROM vertex2delete:v POST-ACCUM DELETE(v);
}

CREATE OR REPLACE QUERY neighbors(VERTEX<Identities> p, INT depth) FOR GRAPH IdentityGraph { 
  SetAccum<EDGE> @@edges;
  SetAccum<VERTEX> @@vertices;
  OrAccum @visited = FALSE;
  OrAccum @visited2 = FALSE;

  seed (Identities) = {p};
  WHILE(seed.size()>0) LIMIT depth DO
    SetAccum<VERTEX> @@pool;
    proof = SELECT v FROM seed-((Proof_Forward>|<Proof_Forward|Proof_Backward>|<Proof_Backward):pf)-Identities:v-((Proof_Forward>|<Proof_Forward|Proof_Backward>|<Proof_Backward):pw)-seed
           WHERE v.@visited == FALSE
           ACCUM @@edges += pf, @@edges += pw
           POST-ACCUM v.@visited = TRUE, @@vertices += v, @@pool += v;
    hold = SELECT v FROM seed-((Hold_Identity>|<Hold_Identity):e)-Identities:v
           WHERE v.@visited2 == FALSE
           ACCUM @@edges += e
           POST-ACCUM v.@visited2 = TRUE, @@vertices += v, @@pool += v;
    seed (Identities) = {@@pool};
  END;
  PRINT @@vertices AS vertices, @@edges AS edges;
}

CREATE OR REPLACE QUERY neighbors_with_source_reverse(VERTEX<Identities> p, INT depth=10, INT reverse_flag=0) FOR GRAPH IdentityGraph SYNTAX V2 {
  MinAccum<INT> @min_dis;
  OrAccum @or_visited = false;
  OrAccum @or_visited2 = false;
  OrAccum @reverse = false;
  ListAccum<VERTEX<Identities>> @path_list;
  SetAccum<STRING> @source_list;
  SetAccum<EDGE> @@edge_set;
  SetAccum<VERTEX<Identities>> @@vertices;
  ListAccum<STRING> @@domainSystems = ["dotbit", "lens", "unstoppabledomains", "space_id", "crossbell"];

  ##### Initialization  #####
  seed (Identities) = {p};
  seed = SELECT s
           FROM seed:s
     ACCUM s.@or_visited += true,
           s.@or_visited2 += true,
           s.@min_dis = 0,
           s.@path_list = s;
  ResultSet (Identities) = seed;

  ##### Calculate distances and paths #####
  WHILE(seed.size()>0) LIMIT depth DO
    SetAccum<VERTEX> @@pool;
    proof = SELECT t
      FROM seed:s1-((Proof_Forward>|<Proof_Forward|Proof_Backward>|<Proof_Backward):pf)-Identities:t-((Proof_Forward>|<Proof_Forward|Proof_Backward>|<Proof_Backward):pw)-seed:s2
        WHERE t.@or_visited == false AND s1 == s2
          ACCUM
            t.@min_dis += s1.@min_dis + 1,
            t.@path_list = s1.@path_list + [t],
            t.@source_list += s1.@source_list,
            t.@source_list += pf.source,
            t.@source_list += pw.source,
            t.@or_visited += true
          POST-ACCUM @@pool += t
        ORDER BY getvid(t);
    ResultSet (Identities) = ResultSet UNION proof;

    hold = SELECT v
      FROM seed:s-((Hold_Identity>|<Hold_Identity):e)-Identities:v
        WHERE v.@or_visited2 == false
        ACCUM
          v.@min_dis += s.@min_dis + 1,
          v.@path_list = s.@path_list + [v],
          v.@source_list += s.@source_list,
          v.@source_list += e.source,
          v.@or_visited2 += true
        POST-ACCUM @@pool += v
      ORDER BY getvid(v);
    ResultSet (Identities) = ResultSet UNION hold;

    seed (Identities) = {@@pool};
  END;
  
  address = SELECT addr FROM ResultSet:start-((<Reverse_Resolve):r)-ResultSet:addr
            WHERE @@domainSystems.contains(r.system) == TRUE
            ACCUM start.@reverse += true;
  
  address2 = SELECT addr FROM ResultSet:addr-((Reverse_Resolve_Contract>):r)-Contracts:c
            WHERE r.system == "ENS"
            ACCUM addr.@reverse += true;
  
  IF reverse_flag == 0 THEN
    PRINT ResultSet as vertices;
  ELSE IF reverse_flag == 1 THEN
    PRINT ResultSet as vertices WHERE (@@domainSystems.contains(ResultSet.platform) == TRUE AND ResultSet.@reverse == TRUE) OR
      (@@domainSystems.contains(ResultSet.platform) == FALSE);
  ELSE IF reverse_flag == 2 THEN
    PRINT ResultSet as vertices WHERE (@@domainSystems.contains(ResultSet.platform) == TRUE AND ResultSet.@reverse == FALSE) OR
      (@@domainSystems.contains(ResultSet.platform) == FALSE);
  END;
}

CREATE OR REPLACE QUERY neighbors_with_source(VERTEX<Identities> p, INT depth=10) FOR GRAPH IdentityGraph SYNTAX V2 { 
  MinAccum<INT> @min_dis;
  OrAccum @or_visited = false;
  OrAccum @or_visited2 = false;
  ListAccum<VERTEX<Identities>> @path_list;
  SetAccum<STRING> @source_list;
  SetAccum<EDGE> @@edge_set;

  ##### Initialization  #####
  seed (Identities) = {p};
  seed = SELECT s
           FROM seed:s
     ACCUM s.@or_visited += true,
           s.@min_dis = 0,
           s.@path_list = s;
  ResultSet = {p};

  ##### Calculate distances and paths #####
  WHILE(seed.size()>0) LIMIT depth DO
    SetAccum<VERTEX> @@pool;
    proof = SELECT t
      FROM seed:s1-((Proof_Forward>|<Proof_Forward|Proof_Backward>|<Proof_Backward):pf)-Identities:t-((Proof_Forward>|<Proof_Forward|Proof_Backward>|<Proof_Backward):pw)-seed:s2
        WHERE t.@or_visited == false AND s1 == s2
          ACCUM
            t.@min_dis += s1.@min_dis + 1,
            t.@path_list = s1.@path_list + [t],
            t.@source_list += s1.@source_list,
            t.@source_list += pf.source,
            t.@source_list += pw.source,
            t.@or_visited += true
          POST-ACCUM @@pool += t
        ORDER BY getvid(t);
    ResultSet = ResultSet UNION proof;

    hold = SELECT v
      FROM seed:s-((Hold_Identity>|<Hold_Identity):e)-Identities:v
        WHERE v.@or_visited2 == false
        ACCUM
          v.@min_dis += s.@min_dis + 1,
          v.@path_list = s.@path_list + [v],
          v.@source_list += s.@source_list,
          v.@source_list += e.source,
          v.@or_visited2 += true
        POST-ACCUM @@pool += v
      ORDER BY getvid(v);
    ResultSet = ResultSet UNION hold;

    seed (Identities) = {@@pool};
  END;
  PRINT ResultSet AS vertices;
}


CREATE OR REPLACE QUERY identity_by_source(VERTEX<Identities> p, STRING source) FOR GRAPH IdentityGraph SYNTAX V2 {
  start (Identities) = {p};
  vertices = SELECT v FROM start-((Proof_Forward>|Proof_Backward>):e)-Identities:v
            WHERE e.source == source;
  PRINT vertices;
}

CREATE OR REPLACE QUERY owners_by_ids(SET<STRING> ids) FOR GRAPH IdentityGraph SYNTAX V2 {
  start (Identities) = SELECT s FROM Identities:s WHERE s.id IN ids;
  # SumAccum<STRING> @query_id;
  MapAccum<VERTEX<Identities>, VERTEX<Identities>> @@owners_map;
  vertices = SELECT v FROM start:s-((<Hold_Identity):e)-Identities:v
            ACCUM @@owners_map += (s -> v);
  FOREACH (query_id, owner) IN @@owners_map DO
    identity (Identities) = { owner };
    PRINT query_id as query_id, identity;
  END;
}

CREATE OR REPLACE QUERY neighbor_reverse_by_ids(SET<STRING> ids) FOR GRAPH IdentityGraph SYNTAX V2 {
  MapAccum<VERTEX<Identities>, BOOL> @@reverse_map;
  // Init.
  VertexSet (Identities) = SELECT s FROM Identities:s WHERE s.id IN ids
                          ACCUM @@reverse_map += (s -> false);
  ListAccum<STRING> @@domainSystems = ["dotbit", "lens", "unstoppabledomains", "space_id", "crossbell"];

  address = SELECT addr FROM VertexSet:domain-((<Reverse_Resolve):r)-Identities:addr
            WHERE @@domainSystems.contains(r.system) == TRUE
            ACCUM @@reverse_map += (domain -> true);
  
  address2 = SELECT addr FROM VertexSet:addr-((Reverse_Resolve_Contract>):r)-Contracts:c
            WHERE r.system == "ENS"
            ACCUM @@reverse_map += (addr -> true);
  PRINT @@reverse_map as reverse_map;
}


CREATE OR REPLACE QUERY identities_by_ids(SET<STRING> ids) FOR GRAPH IdentityGraph SYNTAX V2 {
  vertices = SELECT s FROM Identities:s WHERE s.id IN ids;
  PRINT vertices;
}

CREATE OR REPLACE QUERY identity_owned_by(VERTEX<Identities> p, STRING platform) FOR GRAPH IdentityGraph SYNTAX V2 {
  start (Identities) = {p};
  owner = SELECT v FROM start-((<Hold_Identity):e)-Identities:v
        WHERE e.source == platform;
  PRINT owner;
}

CREATE OR REPLACE QUERY hold_nft(STRING id, STRING chain, STRING address) FOR GRAPH IdentityGraph SYNTAX V2 {
  SetAccum<EDGE> @@holds;
  contract = SELECT v FROM Identities:s-((Hold_Contract>):e)-Contracts:v
        WHERE v.chain == chain AND v.address == address AND e.id == id
        ACCUM
          @@holds += e;
  PRINT @@holds AS holds;
}

CREATE OR REPLACE QUERY nfts(VERTEX<Identities> p, SET<STRING> categories, INT numPerPage = 100, INT pageNum = 0) FOR GRAPH IdentityGraph {
  SetAccum<EDGE> @@edges;
  start (Identities) = {p};
  
  IF categories.size() > 0 THEN
    hold = SELECT v FROM start-((Hold_Contract>):e)-Contracts:v
          WHERE v.category IN categories
          ACCUM @@edges += e
          ORDER BY getvid(v)
          LIMIT numPerPage OFFSET pageNum * numPerPage;
  ELSE
    hold = SELECT v FROM start-((Hold_Contract>):e)-Contracts:v
          ACCUM @@edges += e
          ORDER BY getvid(v)
          LIMIT numPerPage OFFSET pageNum * numPerPage;
  END;
  PRINT @@edges AS edges;
}

CREATE OR REPLACE QUERY reverse_domains(VERTEX<Identities> p, SET<STRING> domainSystems) FOR GRAPH IdentityGraph {
  OrAccum @reverse = FALSE;
  SetAccum<EDGE> @@reverse_records;

  seed (Identities) = {p};
  identity_record = SELECT v FROM seed-((Reverse_Resolve>):e1)-Identities:v-((Resolve>):e2)-seed
                    ACCUM @@reverse_records += e1;
  contract_record = SELECT v FROM seed-((Reverse_Resolve_Contract>):e1)-Contracts:v-((Resolve_Contract>):e2)-seed
                    ACCUM @@reverse_records += e1;

  PRINT @@reverse_records as reverse_records;
}


CREATE OR REPLACE QUERY domain2(STRING name, STRING system) FOR GRAPH IdentityGraph {
  EDGE record;
  EDGE hold;
  EDGE reverse_edge;
  OrAccum @@reverse;
  IF system == "ENS" THEN
    resolved = SELECT v FROM Contracts:c-((Resolve_Contract>):e)-Identities:v
              WHERE e.system == system AND e.name == name
              ACCUM
                record = e;
    reverse_record = SELECT v FROM Identities:v-((Reverse_Resolve_Contract>):e)-Contracts:c
              WHERE e.system == system AND e.name == name
              ACCUM
                reverse_edge = e,
                @@reverse += TRUE;
    owner = SELECT s FROM Identities:s-((Hold_Contract>):e)-Contracts:v
              WHERE e.id == name
              ACCUM
                hold = e;
    PRINT record, hold, resolved, owner, @@reverse as reverse, reverse_record;
  ELSE
    resolved = SELECT v FROM Identities:s-((Resolve>):e)-Identities:v
              WHERE e.system == system AND e.name == name
              ACCUM
                record = e;
    reverse_record = SELECT v FROM Identities:v-((Reverse_Resolve>):e)-Identities:tgt
              WHERE e.system == system AND e.name == name
              ACCUM
                reverse_edge = e,
                @@reverse += TRUE;
    owner = SELECT s FROM Identities:s-((Hold_Identity>):e)-Identities:v
              WHERE v.platform == system AND v.identity == name
              ACCUM
                hold = e;
    PRINT record, hold, resolved, owner, @@reverse as reverse, reverse_record;
  END;
}

CREATE OR REPLACE QUERY domain(STRING name, STRING system) FOR GRAPH IdentityGraph {
  EDGE record;
  EDGE hold;
  IF system == "ENS" THEN
    resolved = SELECT v FROM Contracts:c-((Resolve_Contract>):e)-Identities:v
              WHERE e.system == system AND e.name == name
              ACCUM
                record = e;
    owner = SELECT s FROM Identities:s-((Hold_Contract>):e)-Contracts:v
              WHERE e.id == name
              ACCUM
                hold = e;
    PRINT record, hold, resolved, owner;
  ELSE
    resolved = SELECT v FROM Identities:s-((Resolve>):e)-Identities:v
              WHERE e.system == system AND e.name == name
              ACCUM
                record = e;
    owner = SELECT s FROM Identities:s-((Hold_Identity>):e)-Identities:v
              WHERE v.platform == system AND v.identity == name
              ACCUM
                hold = e;
    PRINT record, hold, resolved, owner;
  END;
}

CREATE OR REPLACE QUERY contracts_by_ids(SET<STRING> ids) FOR GRAPH IdentityGraph SYNTAX V2 {
  vertices = SELECT s FROM Contracts:s WHERE s.id IN ids;
  PRINT vertices;
}

CREATE OR REPLACE QUERY expand(VERTEX<Identities> p, INT depth) FOR GRAPH IdentityGraph { 
  SetAccum<EDGE> @@edges;
  OrAccum @visited = FALSE;

  seed (Identities) = {p};
  FOREACH i in RANGE[1, depth] DO
    seed = SELECT v FROM seed-((Relation_Unique_TX>|<Relation_Unique_TX|Social_Feed>|<Social_Feed|Relation_TX>|<Relation_TX):e)-Identities:v
           WHERE v.@visited == FALSE
           ACCUM @@edges += e, v.@visited = TRUE;
  END;
  PRINT @@edges AS relations;
}

CREATE OR REPLACE QUERY relation_single_pair(VERTEX<Identities> v_source, VERTEX<Identities> target_v, INT depth = 10) FOR GRAPH IdentityGraph {
  ListAccum<ListAccum<VERTEX>> @path_list; 
  ListAccum<ListAccum<VERTEX>> @new_list;
  OrAccum @end_point;
  ListAccum<ListAccum<VERTEX>> @@total_path_list; // all vertex as List
  SetAccum<EDGE> @@total_edge_list; // all edge as Set

  endset = {target_v};
  endset = SELECT s
          From endset:s
          ACCUM s.@end_point = true;
  
  Source = {v_source};
  Source = SELECT s 
           FROM Source:s
           ACCUM s.@path_list = [s];
  
  WHILE Source.size() > 0 LIMIT depth DO 
       Source = SELECT t 
                 FROM Source:s-((Relation_Unique_TX>|<Relation_Unique_TX|Social_Feed>|<Social_Feed|Relation_TX>|<Relation_TX):e)-Identities:t
                 ACCUM @@total_edge_list += e,
                 FOREACH sequence IN s.@path_list DO 
                   IF t.@end_point == true THEN
                     @@total_path_list += [sequence + [t]]
                   ELSE IF sequence.contains(t) == FALSE THEN
                     t.@new_list += [sequence + [t]]  
                   END
                 END
        POST-ACCUM s.@path_list.clear();
  
      Source = SELECT t 
                FROM Source:t    
                POST-ACCUM t.@path_list = t.@new_list,
                           t.@new_list.clear()
                HAVING t.@path_list.size() > 0;
  END;
  PRINT @@total_path_list as path, @@total_edge_list as relations;
}


CREATE OR REPLACE QUERY tg_louvain(SET<STRING> v_type_set, SET<STRING> e_type_set, STRING weight_attribute = "weight", INT maximum_iteration = 10,
  STRING result_attribute = "cid", STRING file_path = "", BOOL print_stats = FALSE)  SYNTAX V1 {
  TYPEDEF TUPLE <FLOAT deltaQ, FLOAT weight, VERTEX cc> move;
  SumAccum<FLOAT> @sum_ac; #sum of the degrees of all the vertices in community C of the vertex
  ListAccum<VERTEX> @cc_list; #the community center
  SumAccum<FLOAT> @sum_weight; # total weight incident to this vertex
  SumAccum<FLOAT> @sum_cc_weight; # total weight incident to the cc vertex
  MapAccum<VERTEX,SumAccum<FLOAT>> @A_map; #A[c]: sum of the edge weights for the edges in community c
  MaxAccum<move> @max_best_move; # highest dQ, highest -Outdegree, highest cc
  ListAccum<VERTEX> @cm_list;  #community member list
  SumAccum<FLOAT> @@sum_m; # total edge weight
  SumAccum<INT> @sum_outdegree;   # helper variable for outdegree calculation
  SumAccum<INT> @@sum_cc_change;
  MapAccum<INT, SumAccum<INT>> @@community_map;
  MapAccum<INT, SumAccum<INT>> @@community_size_count;
  FILE f(file_path);

  // initialize
  Start = {v_type_set};
  Start = SELECT s
          FROM Start:s -(e_type_set:e)- :t
          ACCUM
              @@sum_m += e.getAttr(weight_attribute, "FLOAT")*0.5,
              s.@sum_weight += e.getAttr(weight_attribute, "FLOAT")*1.0,
              s.@sum_cc_weight += e.getAttr(weight_attribute, "FLOAT")*1.0,
              s.@sum_outdegree += 1
          // mark @cc only for vertices with more than 1 neighbors
          // and only the marked vertices will participate in the actual louvain algorithm
          // the unmorked vertices will be resolved by the vertex following heuristic
          POST-ACCUM
              IF s.@sum_outdegree > 1 THEN
                  s.@cc_list += s
              END;
  IF print_stats THEN
      PRINT Start.size() AS AllVertexCount;
  END;

  // special @cc update in the first iteration
  Start = SELECT t
          FROM Start:s -(e_type_set:e)- :t
          WHERE s.@sum_outdegree > 1 AND t.@sum_outdegree > 1
          ACCUM
              t.@max_best_move += move(e.getAttr(weight_attribute, "FLOAT")*1.0 + @@sum_m*t.@sum_weight *
              (t.@sum_weight - s.@sum_weight), -s.@sum_cc_weight, s.@cc_list.get(0))
          POST-ACCUM
              IF t.@max_best_move.deltaQ > 0 THEN
                  IF -t.@max_best_move.weight < t.@sum_cc_weight THEN
                      t.@cc_list.clear(),
                      t.@cc_list += t.@max_best_move.cc,
                      t.@sum_cc_weight = -t.@max_best_move.weight,
                      @@sum_cc_change += 1
                  ELSE
                      IF abs((-t.@max_best_move.weight) - (t.@sum_cc_weight)) < 0.0001 AND getvid(t) < getvid(t.@max_best_move.cc)  THEN
                          t.@cc_list.clear(),
                          t.@cc_list += t.@max_best_move.cc,
                          t.@sum_cc_weight = -t.@max_best_move.weight,
                          @@sum_cc_change += 1
                      END
                  END
              END;
  IF print_stats THEN
      PRINT @@sum_cc_change AS InitChangeCount;
  END;

  // main loop
  WHILE @@sum_cc_change > 0 LIMIT maximum_iteration DO
      // initialize for iteration
      @@sum_cc_change = 0;
      Start = SELECT s
              FROM Start:s
              WHERE s.@sum_outdegree > 1
              POST-ACCUM
                  s.@sum_ac = 0,
                  s.@cm_list.clear(),
                  s.@A_map.clear();

      Start = SELECT s
              FROM Start:s
              ACCUM
                  FOREACH v IN s.@cc_list DO
                      CASE WHEN getvid(v) != -1 THEN
                          v.@cm_list += s
                      END
                  END;

      Start = SELECT s
              FROM Start:s -(e_type_set:e)- :t
              WHERE t.@sum_outdegree > 1
              ACCUM
                  s.@A_map += (t.@cc_list.get(0) -> e.getAttr(weight_attribute, "FLOAT")*1.0);

      Start = SELECT s
              FROM Start:s
              ACCUM
                  FOREACH v IN s.@cc_list DO
                      CASE WHEN getvid(v) != -1 THEN
                          v.@sum_ac += s.@sum_weight
                      END
                  END;

      Start = SELECT s
              FROM Start:s
              ACCUM
                  FOREACH v IN s.@cm_list DO
                      CASE WHEN getvid(v) != -1 THEN
                          v.@sum_ac = s.@sum_ac
                      END
                  END;

      // compute @max_dQ
      Start = SELECT s
              FROM Start:s -(e_type_set:e)- :t
              WHERE t.@sum_outdegree > 1
              ACCUM
                  INT A_s = 0,
                  IF s.@A_map.containsKey(s) THEN
                      A_s = s.@A_map.get(s)
                  END,
                  s.@max_best_move += move(s.@A_map.get(t.@cc_list.get(0)) - A_s +
                  1/@@sum_m*s.@sum_weight*(s.@sum_ac-t.@sum_ac), -t.@sum_cc_weight, t.@cc_list.get(0))
              POST-ACCUM
                  IF s.@max_best_move.deltaQ > 0 THEN
                      IF -s.@max_best_move.weight < s.@sum_cc_weight THEN   // smallest best_move weight < current weight
                          s.@cc_list.clear(),
                          s.@cc_list += s.@max_best_move.cc,
                          s.@sum_cc_weight = -s.@max_best_move.weight,
                          @@sum_cc_change += 1
                      ELSE
                          IF abs((-s.@max_best_move.weight) - (s.@sum_cc_weight)) < 0.0001 AND getvid(s.@cc_list.get(0)) < getvid(s.@max_best_move.cc)  THEN
                              s.@cc_list.clear(),
                              s.@cc_list += s.@max_best_move.cc,
                              s.@sum_cc_weight = -s.@max_best_move.weight,
                              @@sum_cc_change += 1
                          END
                      END
                  END;
      IF print_stats THEN
          PRINT @@sum_cc_change AS IterChangeCount;
      END;
  END;

  // process node with outdegree=1
  // follow the vertex to its neighbor's community
  // if the neighbor also have outdegree=1, mark the two vertices as one community
  Start = {v_type_set};
  Start = SELECT s
          FROM Start:s -(e_type_set:e)- :t
          WHERE s.@sum_outdegree == 1 AND t.@sum_outdegree != 1
          ACCUM
              s.@cc_list += t.@cc_list.get(0);
  IF print_stats THEN
      PRINT Start.size() AS VertexFollowedToCommunity;
  END;

  Start = {v_type_set};
  Start = SELECT s
          FROM Start:s -(e_type_set:e)- :t
          WHERE s.@sum_outdegree == 1 AND t.@sum_outdegree == 1
          ACCUM
              IF getvid(s) <= getvid(t) THEN
                  s.@cc_list += s
              ELSE
                  s.@cc_list += t
              END;
  IF print_stats THEN
      PRINT Start.size() AS VertexFollowedToVertex;
  END;

  // process node with outdegree=0
  // assign them to communities containing only itself
  Start = {v_type_set};
  Start = SELECT s
          FROM Start:s
          WHERE s.@sum_outdegree == 0
          ACCUM
              s.@cc_list += s;
  IF print_stats THEN
      PRINT Start.size() AS VertexAssignedToItself;
  END;

  // save result
  Start = {v_type_set};
  Start = SELECT s
          FROM Start:s
          POST-ACCUM
              IF result_attribute != "" THEN
                  s.setAttr(result_attribute, getvid(s.@cc_list.get(0)))
              END,
              IF file_path != "" THEN
                  f.println(s, getvid(s.@cc_list.get(0)), s.@cc_list.get(0))
              END;

  // print result satistic
  IF print_stats THEN
      Start = SELECT s
              FROM Start:s
              WHERE s.@cc_list.size() > 0
              POST-ACCUM
                  @@community_map += (getvid(s.@cc_list.get(0)) -> 1);
      PRINT @@community_map.size() AS FinalCommunityCount;
  END;
}

CREATE OR REPLACE QUERY tg_fastRP(
  SET<STRING> v_type_set,
  SET<STRING> e_type_set,
  SET<STRING> output_v_type_set,
  STRING iteration_weights,
  FLOAT beta,
  INT embedding_dimension,
  INT default_index = 0,
  INT default_length,
  FLOAT default_weight = 1,
  SET<STRING> embedding_dim_map,
  INT sampling_constant = 3,
  INT random_seed = 42,
  STRING result_attribute="",
  STRING component_attribute="",
  INT batch_number=0,
  STRING filepath="",
  BOOL print_results=FALSE,
  INT choose_k=5) SYNTAX V1 {
  TYPEDEF TUPLE<INT min_dim, INT max_dim, FLOAT weight> Dim_Tuple;

  MapAccum<STRING, Dim_Tuple> @@feature_dim_map, @@embedding_dim_map;

  MapAccum<INT, SumAccum<FLOAT>> @embedding_arr;
  MapAccum<INT, SumAccum<FLOAT>> @final_embedding_arr;
  ListAccum<DOUBLE> @final_embedding_list;
  SumAccum<FLOAT> @L, @@m, @@n;
  ListAccum<FLOAT> @@weights;
  OrAccum @include, @stop;
  INT weight_idx, defined_dims;

  STRING temp_dim_key;
  INT idx_1, idx_2, idx_3, temp_length, temp_weight, emb_idx;
  INT _edge_sample_cutoff;

  FILE f(filepath);

  // PRE-INITIALIZATION

  // initialization of internal variables for PRNG
  INT _mod, _mult, _inc;
  _mod = pow(2, 31)-1;
  _mult = 1664525;
  _inc = 1013904223;
  FLOAT p1, p2, p3, v1, v2, v3;
  v1 = sqrt(sampling_constant);
  v2 = -v1;
  v3 = 0.0;
  p1 = 0.5 / sampling_constant;
  p2 = p1;
  p3 = 1 - 1.0 / sampling_constant;

  // extract explicitly defined topological embedding regions
  FOREACH string_tuple IN embedding_dim_map DO
    idx_1 = instr(string_tuple, ",");
    idx_2 = instr(string_tuple, ",", 0, 2);
    idx_3 = instr(string_tuple, ",", 0, 3);
    temp_dim_key = substr(string_tuple, 0, idx_1);
    PRINT idx_1, idx_2, idx_3;
    temp_length = str_to_int(substr(string_tuple, idx_1+1, idx_2-1-idx_1));
    temp_weight = str_to_float(substr(string_tuple, idx_2+1));
    idx_3 = str_to_int(substr(string_tuple, idx_3+1));
    @@embedding_dim_map += (temp_dim_key -> Dim_Tuple(idx_3, idx_3+temp_length, temp_weight));
    defined_dims = defined_dims + temp_length;
  END;

  @@embedding_dim_map += ("default" -> Dim_Tuple(default_index, default_index+default_length, default_weight));

  PRINT @@embedding_dim_map;

  // extract weights into usable accumulator
  idx_1 = 0;
  weight_idx = 1;
  WHILE idx_1 != -1 DO
    idx_2 = instr(iteration_weights, ",", idx_1);
    IF idx_2 == -1 THEN
      @@weights += str_to_float(substr(iteration_weights, idx_1));
      BREAK;
    END;
    @@weights += str_to_float(substr(iteration_weights, idx_1, idx_2-idx_1));
    idx_1 = idx_2+1;
    weight_idx = weight_idx + 1;
  END;

  verts = {v_type_set};
  // component_attr should indicate which batch each vertex belongs to, if none defined, just use all vertex types provided
  IF component_attribute != "" THEN
    verts =
      SELECT s FROM verts:s
      WHERE s.getAttr(component_attribute, "INT") == batch_number
      POST-ACCUM s.@include += TRUE;
  ELSE
    verts =
      SELECT s FROM verts:s POST-ACCUM s.@include += TRUE;
  END;

  // INITIALIZATION

  // L stores the normalized diagonal elements of an inverse degree matrix
  // this is defined in the original algorithm and is useful for initialization
  verts =
    SELECT s FROM verts:s -(e_type_set:e)- v_type_set:t
    WHERE t.@include == TRUE
    ACCUM @@m += 1
    POST-ACCUM s.@L = pow(s.outdegree(e_type_set) / @@m, beta);

  PRINT @@m as accum_m;

  // randomly initialize the topological embedding regions
  verts =
    SELECT s FROM verts:s -(e_type_set:e)- v_type_set:t
    WHERE t.@include == TRUE
    ACCUM
      // PRNG code
      INT inc = (getvid(s)+_inc),
      INT r = ((inc+_mult*random_seed) % _mod),
      FLOAT mr = 0,
      STRING temp_e_type = e.type,
      // if the edge type wasn't explicitly specified, but was provided in e_type_set,
      // then its information will reside in the 'default' region of the embedding vector
      IF @@embedding_dim_map.containsKey(e.type) == FALSE THEN
        temp_e_type = "default"
      END,
      FLOAT weight = @@embedding_dim_map.get(temp_e_type).weight,
      FOREACH i IN RANGE[@@embedding_dim_map.get(temp_e_type).min_dim, @@embedding_dim_map.get(temp_e_type).max_dim-1] DO
        r = ((r * _mult + inc) % _mod),
        mr = r / (_mod * 1.0),
        if (mr <= p1 + 0.0001) THEN
          t.@embedding_arr += (i -> v1 * s.@L * weight)
        ELSE IF (mr <= p1 + p2 + 0.0001) THEN
          t.@embedding_arr += (i -> v2 * s.@L * weight)
        ELSE
          t.@embedding_arr += (i -> v3 * s.@L * weight)
        END
      END;

   // MAIN EXECUTION

  PRINT @@weights.size()-1 as iteration;

  FOREACH depth IN RANGE[0, @@weights.size()-1] DO

    // propagate embeddings to neighbors and normalize
    verts =
      SELECT s FROM verts:s -(e_type_set)- v_type_set:t
      WHERE t.@include == TRUE
      ACCUM
        t.@embedding_arr += s.@embedding_arr
      POST-ACCUM
        // first calculate square sum to help normalize
        FLOAT square_sum = 0,
        FLOAT out = max([1.0, t.outdegree(e_type_set)]),
        FOREACH (i,total) IN t.@embedding_arr DO
          square_sum = square_sum + pow(total / out, 2)
        END,
        square_sum = sqrt(square_sum),
        FLOAT value = 0,
        FOREACH i IN RANGE[0, embedding_dimension-1] DO
          IF abs((square_sum) - (0.0)) < 0.00001 THEN
            BREAK
          END,
          t.@final_embedding_arr += (i -> t.@embedding_arr.get(i) / out / square_sum * @@weights.get(depth)),
          value = t.@embedding_arr.get(i) / out / square_sum,
          t.@embedding_arr += (i -> -t.@embedding_arr.get(i)),
          t.@embedding_arr += (i -> value)
        END;
    depth = depth + 1;
  END;

  // OUTPUT

  // clearing the unneeded arrays will save on memory
  verts =
    SELECT s FROM verts:s
    POST-ACCUM s.@embedding_arr.clear();

  // the arrays are converted to lists for compatibility with GSQL's LIST type
  verts =
    SELECT s FROM verts:s
    WHERE output_v_type_set.size() == 0 OR output_v_type_set.contains(s.type)
    POST-ACCUM
    FOREACH i IN RANGE[0, embedding_dimension-1] DO
      s.@final_embedding_list += s.@final_embedding_arr.get(i) / @@weights.size() // Average by # of iterations
    END,
    s.@final_embedding_arr.clear();

  IF print_results THEN
    res = SELECT a FROM verts:a;
    PRINT res[res.@final_embedding_arr];
  END;

  // (un)comment depending on whether you want to write to graph
  // GSQL does not yet support dynamic setAttr calls for LIST types
  IF result_attribute != "" THEN
    storeEmbeddings = SELECT s FROM verts:s POST-ACCUM s.setAttr(result_attribute, s.@final_embedding_list);
  END;
  IF filepath != "" THEN
    res = SELECT s FROM verts:s POST-ACCUM f.println(s, s.@final_embedding_list);
  END;
}


INSTALL QUERY ALL

