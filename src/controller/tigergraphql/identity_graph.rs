use crate::{
    controller::tigergraphql::identity::DataStatus,
    error::{Error, Result},
    tigergraph::{
        edge::{EdgeUnion, HoldRecord},
        vertex::{
            Address, ExpandIdentityRecord, IdentityConnection, IdentityGraph, IdentityRecord,
            IdentityWithSource, OwnerLoadFn,
        },
    },
    upstream::{fetch_all, Chain, ContractCategory, DataSource, Platform, Target},
    util::{make_http_client, naive_now},
};
use async_graphql::{Context, Object};
use chrono::Duration;
use dataloader::non_cached::Loader;
use tracing::{event, Level};
use uuid::Uuid;

#[derive(Default)]
pub struct IdentityGraphQuery;

#[Object]
impl IdentityGraph {
    /// Connecting a personâ€™s different identifiers together, form an identity graph
    async fn graph_id(&self) -> String {
        self.graph_id.clone()
    }

    /// The set of vertices forming a identity graph.
    async fn vertices(&self) -> &Vec<ExpandIdentityRecord> {
        &self.vertices
    }

    /// The set of edges forming a identity graph.
    async fn edges(&self) -> &Vec<IdentityConnection> {
        &self.edges
    }
}

#[Object]
impl Address {
    /// On which chain?
    async fn chain(&self) -> Chain {
        self.chain
    }

    /// Address
    async fn address(&self) -> String {
        self.address.clone()
    }
}

#[Object]
impl ExpandIdentityRecord {
    /// Status for this record in RelationService.
    async fn status(&self) -> Vec<DataStatus> {
        use DataStatus::*;
        let mut current: Vec<DataStatus> = vec![];
        if !self.v_id().is_empty() {
            current.push(Cached);
            if self.is_outdated() {
                current.push(Outdated);
            }
        } else {
            current.push(Fetching); // FIXME: Seems like this is never reached.
        }
        current
    }

    async fn id(&self) -> String {
        self.v_id().clone()
    }

    /// UUID of this record.  Generated by us to provide a better
    /// global-uniqueness for future P2P-network data exchange
    /// scenario.
    async fn uuid(&self) -> Option<Uuid> {
        self.uuid
    }

    /// Platform.  See `avaliablePlatforms` or schema definition for a
    /// list of platforms supported by RelationService.
    async fn platform(&self) -> Platform {
        self.platform
    }

    /// Identity on target platform.  Username or database primary key
    /// (prefer, usually digits).  e.g. `Twitter` has this digits-like
    /// user ID thing.
    async fn identity(&self) -> String {
        self.identity.clone()
    }

    /// Uid on target platform.
    /// uid is the unique ID on each platform
    /// e.g. for `Farcaster`, this is the `fid`, for `Lens` this is the lens profile_id(0xabcd)
    async fn uid(&self) -> Option<String> {
        self.uid.clone()
    }

    /// Usually user-friendly screen name.  e.g. for `Twitter`, this
    /// is the user's `screen_name`.
    /// Note: both `null` and `""` should be treated as "no value".
    async fn display_name(&self) -> Option<String> {
        self.display_name.clone()
    }

    /// URL to target identity profile page on `platform` (if any).
    async fn profile_url(&self) -> Option<String> {
        self.profile_url.clone()
    }

    /// URL to avatar (if any is recorded and given by target platform).
    async fn avatar_url(&self) -> Option<String> {
        self.avatar_url.clone()
    }

    /// Account / identity creation time ON TARGET PLATFORM.
    /// This is not necessarily the same as the creation time of the record in the database.
    /// Since `created_at` may not be recorded or given by target platform.
    /// e.g. `Twitter` has a `created_at` in the user profile API.
    /// but `Ethereum` is obviously no such thing.
    async fn created_at(&self) -> Option<i64> {
        self.created_at.map(|dt| dt.and_utc().timestamp())
    }

    /// When this Identity is added into this database.
    /// Second-based unix timestamp.
    /// Generated by us.
    async fn added_at(&self) -> i64 {
        self.added_at.and_utc().timestamp()
    }

    /// When it is updated (re-fetched) by us RelationService.
    /// Second-based unix timestamp.
    /// Managed by us.
    async fn updated_at(&self) -> i64 {
        self.updated_at.and_utc().timestamp()
    }

    /// The expiry date for the domain, from either the registration, or the wrapped domain if PCC is burned
    async fn expired_at(&self) -> Option<i64> {
        if !vec![
            Platform::Dotbit,
            Platform::ENS,
            Platform::Genome,
            Platform::Basenames,
        ]
        .contains(&self.platform)
        {
            return None;
        }
        self.expired_at.map(|dt| dt.and_utc().timestamp())
    }

    /// reverse flag can be used as a filtering for Identity which type is domain system.
    /// If `reverse=None` if omitted, there is no need to filter anything.
    /// When `reverse=true`, just return `primary domain` related identities.
    /// When `reverse=false`, Only `non-primary domain` will be returned, which is the inverse set of reverse=true.
    async fn reverse(&self) -> Result<Option<bool>> {
        if !vec![
            Platform::Lens,
            Platform::Dotbit,
            Platform::UnstoppableDomains,
            Platform::SpaceId,
            Platform::Crossbell,
            Platform::Ethereum,
            Platform::ENS,
            Platform::Solana,
            Platform::SNS,
            Platform::Genome,
            Platform::Basenames,
        ]
        .contains(&self.platform)
        {
            return Ok(None);
        }
        Ok(self.reverse)
    }

    /// there's only `platform: lens, dotbit, unstoppabledomains, farcaster, space_id` identity `ownedBy` is not null
    async fn owned_by(&self, ctx: &Context<'_>) -> Result<Option<IdentityRecord>> {
        if !vec![
            Platform::Lens,
            Platform::Dotbit,
            Platform::UnstoppableDomains,
            Platform::Farcaster,
            Platform::SpaceId,
            Platform::Crossbell,
            Platform::ENS,
            Platform::SNS,
            Platform::Genome,
            Platform::Basenames,
        ]
        .contains(&self.platform)
        {
            return Ok(None);
        }

        let loader: &Loader<String, Option<IdentityRecord>, OwnerLoadFn> =
            ctx.data().map_err(|err| Error::GraphQLError(err.message))?;

        match loader.try_load(self.v_id.clone()).await {
            Ok(value) => Ok(value),
            Err(e) => match e.kind() {
                std::io::ErrorKind::NotFound => Ok(None), // Not found, so return Ok(None)
                _ => Err(Error::GraphQLError(e.to_string())), // For all other errors, propagate the error
            },
        }
    }

    /// NFTs owned by this identity.
    /// For now, there's only `platform: ethereum` identity has NFTs.
    /// If `category` is provided, only NFTs of that category will be returned.
    async fn nft(
        &self,
        _ctx: &Context<'_>,
        #[graphql(
            desc = "Filter condition for ContractCategory. If missing or empty, all category NFTs will be returned."
        )]
        // TODO: need to change back to ContractCategory when frontend migration is done.
        category: Option<Vec<String>>,
        #[graphql(
            desc = "`limit` used to control the maximum number of records returned by query. It defaults to 100"
        )]
        limit: Option<u16>,
        #[graphql(
            desc = "`offset` determines the starting position from which the records are retrieved in query. It defaults to 0."
        )]
        offset: Option<u16>,
    ) -> Result<Vec<HoldRecord>> {
        let client = make_http_client();
        let parsed_category: Option<Vec<ContractCategory>> = category
            .map(|v| {
                v.into_iter()
                    .map(|s| {
                        s.to_lowercase()
                            .parse::<ContractCategory>()
                            .map_err(Error::from)
                    })
                    .collect::<Result<Vec<ContractCategory>>>()
            })
            .transpose()?;
        self.nfts(
            &client,
            parsed_category,
            limit.unwrap_or(100),
            offset.unwrap_or(0),
        )
        .await
    }

    async fn owner_address(&self) -> Option<Vec<Address>> {
        self.owner_address.clone()
    }

    async fn resolve_address(&self) -> Option<Vec<Address>> {
        self.resolve_address.clone()
    }

    /// Neighbor identity from current. Flattened.
    async fn neighbor(
        &self,
        _ctx: &Context<'_>,
        // #[graphql(
        //     desc = "Upstream source of this connection. Will search all upstreams if omitted."
        // )]
        // upstream: Option<String>,
        #[graphql(desc = "Depth of traversal. 1 if omitted")] depth: Option<u16>,
        #[graphql(
            desc = "This reverse flag can be used as a filtering for Identity which type is domain system .
        If `reverse=None` if omitted, there is no need to filter anything.
        When `reverse=true`, just return `primary domain` related identities.
        When `reverse=false`, Only `non-primary domain` will be returned, which is the inverse set of reverse=true."
        )]
        reverse: Option<bool>,
    ) -> Result<Vec<IdentityWithSource>> {
        let client = make_http_client();
        self.neighbors(&client, depth.unwrap_or(1), reverse).await
    }

    /// Neighbor identity from current. The entire topology can be restored by return records.
    async fn neighbor_with_traversal(
        &self,
        _ctx: &Context<'_>,
        #[graphql(desc = "Depth of traversal. 1 if omitted")] depth: Option<u16>,
    ) -> Result<Vec<EdgeUnion>> {
        let client = make_http_client();
        self.neighbors_with_traversal(&client, depth.unwrap_or(1))
            .await
    }

    /// Identity graph from current.
    async fn identity_graph(
        &self,
        _ctx: &Context<'_>,
        #[graphql(
            desc = "This reverse flag can be used as a filtering for Identity which type is domain system .
    If `reverse=None` if omitted, there is no need to filter anything.
    When `reverse=true`, just return `primary domain` related identities.
    When `reverse=false`, Only `non-primary domain` will be returned, which is the inverse set of reverse=true."
        )]
        reverse: Option<bool>,
    ) -> Result<Option<IdentityGraph>> {
        let client = make_http_client();
        match IdentityGraph::find_graph_by_platform_identity(
            &client,
            &self.platform,
            &self.identity,
            reverse,
        )
        .await?
        {
            None => {
                let target = match self.platform {
                    Platform::ENS => Target::NFT(
                        Chain::Ethereum,
                        ContractCategory::ENS,
                        ContractCategory::ENS.default_contract_address().unwrap(),
                        self.identity.clone(),
                    ),
                    _ => Target::Identity(self.platform.clone(), self.identity.clone()),
                };
                let fetch_result = fetch_all(vec![target], Some(3)).await;
                if fetch_result.is_err() {
                    event!(
                        Level::WARN,
                        ?self.platform,
                        self.identity,
                        err = fetch_result.unwrap_err().to_string(),
                        "Failed to fetch_all"
                    );
                }
                Ok(IdentityGraph::find_graph_by_platform_identity(
                    &client,
                    &self.platform,
                    &self.identity,
                    reverse,
                )
                .await?)
            }
            Some(identity_graph) => {
                // filter out dataSource == "basenames" edges
                let filter_edges: Vec<IdentityConnection> = identity_graph
                    .edges
                    .clone()
                    .into_iter()
                    .filter(|e| e.data_source != DataSource::Basenames)
                    .collect();

                if filter_edges.len() == 0 {
                    // only have basenames edges
                    let basenames_vertex: Vec<ExpandIdentityRecord> = identity_graph
                        .vertices
                        .clone()
                        .into_iter()
                        .filter(|v| {
                            v.record.platform == Platform::Basenames
                                && v.record.identity == self.identity
                        })
                        .collect();

                    if basenames_vertex.len() > 0 {
                        let updated_at = basenames_vertex.first().cloned().unwrap().updated_at;
                        let current_time = naive_now();
                        let duration_since_update = current_time.signed_duration_since(updated_at);
                        // Check if the difference is greater than 2 hours
                        if duration_since_update > Duration::hours(2) {
                            let basename_address = basenames_vertex.first().cloned().unwrap();
                            let resolved_address = match basename_address.resolve_address {
                                Some(addr_list) => {
                                    if addr_list.len() > 0 {
                                        addr_list.first().cloned().unwrap().address
                                    } else {
                                        match basename_address.owner_address {
                                            Some(owner_addr_list) => {
                                                if owner_addr_list.len() > 0 {
                                                    owner_addr_list
                                                        .first()
                                                        .cloned()
                                                        .unwrap()
                                                        .address
                                                } else {
                                                    "".to_string()
                                                }
                                            }
                                            None => "".to_string(),
                                        }
                                    }
                                }
                                None => match basename_address.owner_address {
                                    Some(owner_addr_list) => {
                                        if owner_addr_list.len() > 0 {
                                            owner_addr_list.first().cloned().unwrap().address
                                        } else {
                                            "".to_string()
                                        }
                                    }
                                    None => "".to_string(),
                                },
                            };
                            if resolved_address != "".to_string() {
                                tracing::trace!("Basenames refetching {} ...", resolved_address);
                                let target = Target::Identity(Platform::Ethereum, resolved_address);
                                let fetch_result = fetch_all(vec![target], Some(3)).await;
                                if fetch_result.is_err() {
                                    event!(
                                        Level::WARN,
                                        ?self.platform,
                                        self.identity,
                                        err = fetch_result.unwrap_err().to_string(),
                                        "Failed to fetch_all"
                                    );
                                }
                                return Ok(IdentityGraph::find_graph_by_platform_identity(
                                    &client,
                                    &self.platform,
                                    &self.identity,
                                    reverse,
                                )
                                .await?);
                            }
                        }
                    }
                }
                Ok(Some(identity_graph))
            }
        }
    }
}

#[Object]
impl IdentityConnection {
    /// Returns edge type connects start node and end node.
    async fn edge_type(&self) -> String {
        self.edge_type.clone()
    }

    /// Returns data sources from upstreams supported by RelationService.
    async fn data_source(&self) -> DataSource {
        self.data_source
    }

    /// The start node that forms the edge.
    async fn source(&self) -> String {
        self.source.clone()
    }

    /// The end node that forms the edge.
    async fn target(&self) -> String {
        self.target.clone()
    }
}
