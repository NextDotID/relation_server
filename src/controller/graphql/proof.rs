use aragog::DatabaseConnection;
use async_graphql::{Context, Object};
use uuid::Uuid;

use crate::error::{Error, Result};
use crate::graph::edge::Proof;
use crate::graph::vertex::IdentityRecord;
use crate::graph::Edge;
use crate::graph::{edge::proof::ProofRecord, vertex::Identity};

#[Object]
impl ProofRecord {
    /// UUID of this record. Generated by us to provide a better
    /// global-uniqueness for future P2P-network data exchange
    /// scenario.
    async fn uuid(&self) -> String {
        self.uuid.to_string()
    }

    /// Data source (upstream) which provides this connection info.
    async fn source(&self) -> String {
        self.source.to_string()
    }

    /// ID of this connection in upstream platform to locate (if any).
    async fn record_id(&self) -> Option<String> {
        self.record_id.clone()
    }

    /// When this connection is recorded in upstream platform (if platform gives such data).
    async fn created_at(&self) -> Option<i64> {
        self.created_at.map(|ca| ca.timestamp())
    }

    /// When this connection is fetched by us RelationService.
    async fn updated_at(&self) -> i64 {
        self.updated_at.timestamp()
    }

    async fn from(&self, ctx: &Context<'_>) -> Result<IdentityRecord> {
        let db: &DatabaseConnection = ctx.data().map_err(|err| Error::GraphQLError(err.message))?;
        let from_record: aragog::DatabaseRecord<Identity> = self.from_record(db).await?;

        Ok(from_record.into())
    }

    async fn to(&self, ctx: &Context<'_>) -> Result<IdentityRecord> {
        let db: &DatabaseConnection = ctx.data().map_err(|err| Error::GraphQLError(err.message))?;
        let to_record: aragog::DatabaseRecord<Identity> = self.to_record(db).await?;

        Ok(to_record.into())
    }
}

/// Query entrypoint for `Proof{,Record}`
#[derive(Default)]
pub struct ProofQuery;

#[Object]
impl ProofQuery {
    async fn proof(
        &self,
        ctx: &Context<'_>,
        #[graphql(desc = "UUID of this proof")] uuid: Option<String>,
    ) -> Result<Option<ProofRecord>> {
        let db: &DatabaseConnection = ctx.data().map_err(|err| Error::GraphQLError(err.message))?;
        if uuid.is_none() {
            return Ok(None);
        }
        let uuid = Uuid::parse_str(&uuid.unwrap())?;
        let found = Proof::find_by_uuid(db, &uuid).await?;

        Ok(found)
    }

    /// Prefetch proofs which are prefetchable, e.g. SybilList.
    async fn prefetch_proof(&self) -> Result<String> {
        tokio::spawn(async move {
            let _ = crate::upstream::prefetch().await;
        });
        Ok("Fetching".into())
    }
}
