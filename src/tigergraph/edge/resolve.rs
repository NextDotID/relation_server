use crate::{
    config::C,
    error::Error,
    tigergraph::{
        edge::{Edge, EdgeRecord, EdgeWrapper, FromWithParams, HoldRecord, Wrapper},
        upsert_graph,
        vertex::{Contract, Identity, IdentityRecord, Vertex},
        Attribute, BaseResponse, Edges, Graph, OpCode, Transfer, UpsertGraph,
    },
    upstream::{DataFetcher, DataSource, Platform},
    util::{naive_datetime_from_string, naive_datetime_to_string, naive_now, parse_body},
};

use chrono::{Duration, NaiveDateTime};
use http::uri::InvalidUri;
use hyper::{client::HttpConnector, Body, Client, Method};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::collections::HashMap;
use strum_macros::{Display, EnumIter, EnumString};
use tracing::error;
use uuid::Uuid;

#[derive(
    Default,
    Clone,
    Copy,
    Serialize,
    Deserialize,
    Debug,
    Display,
    PartialEq,
    Eq,
    async_graphql::Enum,
    EnumString,
    EnumIter,
    Hash,
)]
pub enum DomainNameSystem {
    /// ENS name system on the ETH chain.
    /// https://ens.domains
    #[strum(serialize = "ENS")]
    #[serde(rename = "ENS")]
    #[graphql(name = "ENS")]
    ENS,

    /// https://www.did.id/
    #[strum(serialize = "dotbit")]
    #[serde(rename = "dotbit")]
    #[graphql(name = "dotbit")]
    DotBit,

    /// https://api.lens.dev/playground
    #[strum(serialize = "lens")]
    #[serde(rename = "lens")]
    #[graphql(name = "lens")]
    Lens,

    /// https://unstoppabledomains.com/
    #[strum(serialize = "unstoppabledomains")]
    #[serde(rename = "unstoppabledomains")]
    #[graphql(name = "unstoppabledomains")]
    UnstoppableDomains,

    /// https://api.prd.space.id/
    #[strum(serialize = "space_id")]
    #[serde(rename = "space_id")]
    #[graphql(name = "space_id")]
    SpaceId,

    #[default]
    #[strum(serialize = "unknown")]
    #[serde(rename = "unknown")]
    #[graphql(name = "unknown")]
    Unknown,
}

impl From<DomainNameSystem> for Platform {
    fn from(domain: DomainNameSystem) -> Self {
        match domain {
            DomainNameSystem::DotBit => Platform::Dotbit,
            DomainNameSystem::UnstoppableDomains => Platform::UnstoppableDomains,
            DomainNameSystem::Lens => Platform::Lens,
            DomainNameSystem::SpaceId => Platform::SpaceId,
            _ => Platform::Unknown,
        }
    }
}

pub const RESOLVE: &str = "Resolve";
pub const REVERSE_RESOLVE: &str = "Reverse_Resolve";
pub const REVERSE_RESOLVE_CONTRACT: &str = "Reverse_Resolve_Contract";
pub const IS_DIRECTED: bool = true;

/// Edge to identify which `Identity(Ethereum)` a `Contract` is resolving to.
/// Basiclly this is served for `ENS` only.
/// There're 3 kinds of relation between an `Identity(Ethereum)` and `Contract(ENS)` :
/// - `Own` relation: defined in `graph/edge/own.rs`
///   In our system: create `Own` edge from `Identity(Ethereum)` to `Contract(ENS)`.
/// - `Resolve` relation: Find an Ethereum wallet using ENS name (like DNS).
///   In our system: create `Resolve` edge from `Contract(ENS)` to `Identity(Ethereum)`.
/// - `ReverseLookup` relation: Find an ENS name using an Ethereum wallet (like reverse DNS lookup).
///   In our system: set `display_name` for the `Identity(Ethereum)`.
#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct Resolve {
    /// UUID of this record. Generated by us to provide a better
    /// global-uniqueness for future P2P-network data exchange
    /// scenario.
    pub uuid: Uuid,
    /// Data source (upstream) which provides this connection info.
    pub source: DataSource,
    /// Domain Name system
    pub system: DomainNameSystem,
    /// Name of domain (e.g., `vitalik.eth`)
    pub name: String,
    /// Who collects this data.
    /// It works as a "data cleansing" or "proxy" between `source`s and us.
    pub fetcher: DataFetcher,
    /// When this connection is fetched by us RelationService.
    #[serde(deserialize_with = "naive_datetime_from_string")]
    #[serde(serialize_with = "naive_datetime_to_string")]
    pub updated_at: NaiveDateTime,
}

impl Default for Resolve {
    fn default() -> Self {
        Self {
            uuid: Default::default(),
            source: Default::default(),
            name: Default::default(),
            system: Default::default(),
            fetcher: Default::default(),
            updated_at: naive_now(),
        }
    }
}

impl PartialEq for Resolve {
    fn eq(&self, other: &Self) -> bool {
        self.uuid == other.uuid
    }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ResolveRecord(pub EdgeRecord<Resolve>);

impl FromWithParams<Resolve> for EdgeRecord<Resolve> {
    fn from_with_params(
        e_type: String,
        directed: bool,
        from_id: String,
        from_type: String,
        to_id: String,
        to_type: String,
        attributes: Resolve,
    ) -> Self {
        EdgeRecord {
            e_type,
            directed,
            from_id,
            from_type,
            to_id,
            to_type,
            discriminator: None,
            attributes,
        }
    }
}

impl From<EdgeRecord<Resolve>> for ResolveRecord {
    fn from(record: EdgeRecord<Resolve>) -> Self {
        ResolveRecord(record)
    }
}

impl std::ops::Deref for ResolveRecord {
    type Target = EdgeRecord<Resolve>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl std::ops::DerefMut for ResolveRecord {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ResolveAttribute(HashMap<String, Attribute>);

// Implement the `From` trait for converting `ResolveRecord` into a `HashMap<String, Attr>`.
impl Transfer for ResolveRecord {
    fn to_attributes_map(&self) -> HashMap<String, Attribute> {
        let mut attributes_map = HashMap::new();
        attributes_map.insert(
            "uuid".to_string(),
            Attribute {
                value: json!(self.attributes.uuid.to_string()),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        attributes_map.insert(
            "source".to_string(),
            Attribute {
                value: json!(self.attributes.source.to_string()),
                op: None,
            },
        );
        attributes_map.insert(
            "system".to_string(),
            Attribute {
                value: json!(self.attributes.system.to_string()),
                op: None,
            },
        );
        attributes_map.insert(
            "name".to_string(),
            Attribute {
                value: json!(self.attributes.name),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        attributes_map.insert(
            "fetcher".to_string(),
            Attribute {
                value: json!(self.attributes.fetcher.to_string()),
                op: None,
            },
        );
        attributes_map.insert(
            "updated_at".to_string(),
            Attribute {
                value: json!(self.attributes.updated_at),
                op: Some(OpCode::Max),
            },
        );
        attributes_map
    }
}

impl Wrapper<ResolveRecord, Contract, Identity> for Resolve {
    fn wrapper(
        &self,
        from: &Contract,
        to: &Identity,
        name: &str,
    ) -> EdgeWrapper<ResolveRecord, Contract, Identity> {
        let resolve = EdgeRecord::from_with_params(
            name.to_string(),
            IS_DIRECTED,
            from.primary_key(),
            from.vertex_type(),
            to.primary_key(),
            to.vertex_type(),
            self.to_owned(),
        );
        EdgeWrapper {
            edge: ResolveRecord(resolve),
            source: from.to_owned(),
            target: to.to_owned(),
        }
    }
}

#[async_trait::async_trait]
impl Edge<Contract, Identity, ResolveRecord> for ResolveRecord {
    fn e_type(&self) -> String {
        self.e_type.clone()
    }

    fn directed(&self) -> bool {
        // TODO: query from server is the best solution
        self.directed.clone()
    }

    /// Connect 2 vertex.
    async fn connect(
        &self,
        client: &Client<HttpConnector>,
        from: &Contract,
        to: &Identity,
    ) -> Result<(), Error> {
        let reverse_contract = self.attributes.wrapper(from, to, REVERSE_RESOLVE_CONTRACT);
        let edges = Edges(vec![reverse_contract]);
        let graph: UpsertGraph = edges.into();
        upsert_graph(client, &graph, Graph::AssetGraph).await?;
        Ok(())
    }

    /// notice this function is deprecated
    async fn connect_reverse(
        &self,
        _client: &Client<HttpConnector>,
        _from: &Contract,
        _to: &Identity,
    ) -> Result<(), Error> {
        todo!()
    }
}

impl Wrapper<ResolveRecord, Identity, Identity> for Resolve {
    fn wrapper(
        &self,
        from: &Identity,
        to: &Identity,
        name: &str,
    ) -> EdgeWrapper<ResolveRecord, Identity, Identity> {
        let resolve = EdgeRecord::from_with_params(
            name.to_string(),
            IS_DIRECTED,
            from.primary_key(),
            from.vertex_type(),
            to.primary_key(),
            to.vertex_type(),
            self.to_owned(),
        );
        EdgeWrapper {
            edge: ResolveRecord(resolve),
            source: from.to_owned(),
            target: to.to_owned(),
        }
    }
}

#[async_trait::async_trait]
impl Edge<Identity, Identity, ResolveRecord> for ResolveRecord {
    fn e_type(&self) -> String {
        self.e_type.clone()
    }

    fn directed(&self) -> bool {
        // TODO: query from server is the best solution
        self.directed.clone()
    }

    /// Connect 2 vertex.
    async fn connect(
        &self,
        client: &Client<HttpConnector>,
        from: &Identity,
        to: &Identity,
    ) -> Result<(), Error> {
        let resolve_record = self.attributes.wrapper(from, to, RESOLVE);
        let edges = Edges(vec![resolve_record]);
        let graph: UpsertGraph = edges.into();
        upsert_graph(client, &graph, Graph::AssetGraph).await?;
        Ok(())
    }

    /// Connect 2 vertex. For digraph and has reverse edge.
    async fn connect_reverse(
        &self,
        client: &Client<HttpConnector>,
        from: &Identity,
        to: &Identity,
    ) -> Result<(), Error> {
        let reverse_record = self.attributes.wrapper(from, to, REVERSE_RESOLVE);
        let edges = Edges(vec![reverse_record]);
        let graph: UpsertGraph = edges.into();
        upsert_graph(client, &graph, Graph::AssetGraph).await?;
        Ok(())
    }
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct DomainResponse {
    #[serde(flatten)]
    base: BaseResponse,
    results: Option<Vec<Domain>>,
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct Domain {
    record: Option<ResolveRecordObject>,
    hold: Option<HoldRecordObject>,
    resolved: Option<Vec<IdentityRecord>>,
    owner: Vec<IdentityRecord>,
}

#[derive(Clone, Deserialize, Serialize, Debug)]
#[serde(untagged)]
pub enum ResolveRecordObject {
    Nonempty(ResolveRecord),
    Empty {},
}

#[derive(Clone, Deserialize, Serialize, Debug)]
#[serde(untagged)]
pub enum HoldRecordObject {
    Nonempty(HoldRecord),
    Empty {},
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct ResolveEdge {
    pub record: Resolve,
    pub resolved: Option<IdentityRecord>,
    pub owner: Option<IdentityRecord>,
}

impl std::ops::Deref for ResolveEdge {
    type Target = Resolve;

    fn deref(&self) -> &Self::Target {
        &self.record
    }
}
impl std::ops::DerefMut for ResolveEdge {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.record
    }
}
impl From<Resolve> for ResolveEdge {
    fn from(record: Resolve) -> Self {
        ResolveEdge {
            record,
            resolved: None,
            owner: None,
        }
    }
}

impl Resolve {
    pub fn is_outdated(&self) -> bool {
        let outdated_in = Duration::days(1);
        self.updated_at
            .checked_add_signed(outdated_in)
            .unwrap()
            .lt(&naive_now())
    }

    pub async fn find_by_name_system(
        client: &Client<HttpConnector>,
        name: &str,
        domain_system: &DomainNameSystem,
    ) -> Result<Option<ResolveEdge>, Error> {
        let uri: http::Uri = format!(
            "{}/query/{}/domain?name={}&system={}",
            C.tdb.host,
            Graph::AssetGraph.to_string(),
            name.to_string(),
            domain_system.to_string(),
        )
        .parse()
        .map_err(|_err: InvalidUri| Error::ParamError(format!("Uri format Error {}", _err)))?;
        let req = hyper::Request::builder()
            .method(Method::GET)
            .uri(uri)
            .header("Authorization", Graph::AssetGraph.token())
            .body(Body::empty())
            .map_err(|_err| Error::ParamError(format!("ParamError Error {}", _err)))?;
        let mut resp = client.request(req).await.map_err(|err| {
            Error::ManualHttpClientError(format!(
                "query domain | Fail to request: {:?}",
                err.to_string()
            ))
        })?;
        match parse_body::<DomainResponse>(&mut resp).await {
            Ok(r) => {
                if r.base.error {
                    let err_message = format!(
                        "TigerGraph query domain error | Code: {:?}, Message: {:?}",
                        r.base.code, r.base.message
                    );
                    error!(err_message);
                    return Err(Error::General(err_message, resp.status()));
                }

                let result = r
                    .results
                    .and_then(|domain_resp| domain_resp.first().cloned())
                    .and_then(|domain| {
                        domain.hold.map_or(None, |hold_obj| {
                            use HoldRecordObject::*;
                            let resolve_edge = match hold_obj {
                                Nonempty(hold) => {
                                    use ResolveRecordObject::*;
                                    let resolve_edge = match domain.record {
                                        Some(Empty {}) | None => {
                                            let mut resolve_edge = ResolveEdge::from(Resolve {
                                                uuid: hold.attributes.uuid,
                                                source: hold.attributes.source,
                                                system: domain_system.clone(),
                                                name: domain
                                                    .owner
                                                    .first()
                                                    .unwrap()
                                                    .to_owned()
                                                    .attributes
                                                    .identity
                                                    .clone(),
                                                fetcher: hold.attributes.fetcher,
                                                updated_at: hold.attributes.updated_at,
                                            });
                                            resolve_edge.owner = domain.owner.first().cloned();
                                            resolve_edge.resolved = None;
                                            resolve_edge
                                        }
                                        Some(Nonempty(record)) => {
                                            let mut resolve_edge = ResolveEdge::from(Resolve {
                                                uuid: record.attributes.uuid,
                                                source: record.attributes.source,
                                                system: record.attributes.system,
                                                name: record.attributes.name.clone(),
                                                fetcher: record.attributes.fetcher,
                                                updated_at: record.attributes.updated_at,
                                            });
                                            resolve_edge.owner = domain.owner.first().cloned();
                                            resolve_edge.resolved = domain
                                                .resolved
                                                .and_then(|resolves| resolves.first().cloned());
                                            resolve_edge
                                        }
                                    };
                                    Some(resolve_edge)
                                }
                                Empty {} => None,
                            };
                            resolve_edge
                        })
                    });
                Ok(result)
            }
            Err(err) => {
                let err_message = format!("TigerGraph query domain parse_body error: {:?}", err);
                error!(err_message);
                return Err(err);
            }
        }
    }
}
