use crate::{
    error::Error,
    tigergraph::{
        vertex::{FromWithParams, Vertex, VertexRecord},
        Attribute, OpCode, Transfer,
    },
    upstream::{DataSource, Platform},
    util::naive_now,
};

use async_trait::async_trait;
use chrono::{Duration, NaiveDateTime};
use serde::{Deserialize, Serialize};
use serde_json::{json, to_value, Value};
use std::collections::HashMap;
use uuid::Uuid;

pub const VERTEX_NAME: &str = "Identities";

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Identity {
    /// UUID of this record. Generated by us to provide a better
    /// global-uniqueness for future P2P-network data exchange
    /// scenario.
    pub uuid: Option<Uuid>,
    /// Platform.
    pub platform: Platform,
    /// Identity on target platform.
    /// Username or database primary key (prefer, usually digits).
    /// e.g. `Twitter` has this digits-like user ID thing.
    pub identity: String,
    /// Usually user-friendly screen name.
    /// e.g. for `Twitter`, this is the user's `screen_name`.
    /// For `ethereum`, this is the reversed ENS name set by user.
    pub display_name: Option<String>,
    /// URL to target identity profile page on `platform` (if any).
    pub profile_url: Option<String>,
    /// URL to avatar (if any is recorded and given by target platform).
    pub avatar_url: Option<String>,
    /// Account / identity creation time ON TARGET PLATFORM.
    /// This is not necessarily the same as the creation time of the record in the database.
    /// Since `created_at` may not be recorded or given by target platform.
    /// e.g. `Twitter` has a `created_at` in the user profile API.
    /// but `Ethereum` is obviously no such thing.
    pub created_at: Option<NaiveDateTime>,
    /// When this Identity is added into this database. Generated by us.
    pub added_at: NaiveDateTime,
    /// When it is updated (re-fetched) by us RelationService. Managed by us.
    pub updated_at: NaiveDateTime,
}

#[typetag::serde]
impl Vertex for Identity {
    fn primary_key(&self) -> String {
        // self.0.v_id.clone()
        format!("{},{}", self.platform, self.identity)
    }

    fn vertex_type(&self) -> String {
        VERTEX_NAME.to_string()
    }
}

// impl Identity {
//     pub fn primary_key(&self) -> String {
//         format!("{},{}", self.platform, self.identity)
//     }
// }

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct IdentityRecord(VertexRecord<Identity>);

impl FromWithParams<Identity> for IdentityRecord {
    fn from_with_params(v_type: String, v_id: String, attributes: Identity) -> Self {
        IdentityRecord(VertexRecord {
            v_type,
            v_id,
            attributes,
        })
    }
}

impl From<VertexRecord<Identity>> for IdentityRecord {
    fn from(record: VertexRecord<Identity>) -> Self {
        IdentityRecord(record)
    }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct IdentityAttribute(HashMap<String, Attribute>);

impl Transfer for Identity {
    fn to_attributes_map(&self) -> HashMap<String, Attribute> {
        let mut attributes_map = HashMap::new();

        attributes_map.insert(
            "id".to_string(),
            Attribute {
                value: json!(self.primary_key()),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        if let Some(uuid) = self.uuid {
            attributes_map.insert(
                "uuid".to_string(),
                Attribute {
                    value: json!(uuid),
                    op: Some(OpCode::IgnoreIfExists),
                },
            );
        }
        attributes_map.insert(
            "platform".to_string(),
            Attribute {
                value: json!(self.platform),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        attributes_map.insert(
            "identity".to_string(),
            Attribute {
                value: json!(&self.identity),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        if let Some(display_name) = self.display_name.clone() {
            attributes_map.insert(
                "display_name".to_string(),
                Attribute {
                    value: json!(display_name),
                    op: None,
                },
            );
        }
        if let Some(profile_url) = self.profile_url.clone() {
            attributes_map.insert(
                "profile_url".to_string(),
                Attribute {
                    value: json!(profile_url),
                    op: None,
                },
            );
        }
        if let Some(avatar_url) = self.avatar_url.clone() {
            attributes_map.insert(
                "avatar_url".to_string(),
                Attribute {
                    value: json!(avatar_url),
                    op: None,
                },
            );
        }
        if let Some(created_at) = self.created_at {
            attributes_map.insert(
                "created_at".to_string(),
                Attribute {
                    value: json!(created_at),
                    op: Some(OpCode::IgnoreIfExists),
                },
            );
        }

        attributes_map.insert(
            "added_at".to_string(),
            Attribute {
                value: json!(self.added_at),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        attributes_map.insert(
            "updated_at".to_string(),
            Attribute {
                value: json!(self.updated_at),
                op: Some(OpCode::Max),
            },
        );
        attributes_map
    }
}

// Implement the `From` trait for converting `Identity` into a `HashMap<String, Attr>`.
impl From<Identity> for IdentityAttribute {
    fn from(i: Identity) -> Self {
        let mut map = HashMap::new();

        // Convert each field into a key-value pair and insert it into the map.
        map.insert(
            "uuid".to_string(),
            Attribute {
                value: json!(i.uuid),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        map.insert(
            "platform".to_string(),
            Attribute {
                value: json!(i.platform),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        map.insert(
            "identity".to_string(),
            Attribute {
                value: json!(i.identity),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        map.insert(
            "display_name".to_string(),
            Attribute {
                value: json!(i.display_name),
                op: None,
            },
        );
        map.insert(
            "profile_url".to_string(),
            Attribute {
                value: json!(i.profile_url),
                op: None,
            },
        );
        map.insert(
            "avatar_url".to_string(),
            Attribute {
                value: json!(i.avatar_url),
                op: None,
            },
        );
        map.insert(
            "created_at".to_string(),
            Attribute {
                value: json!(i.created_at),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        map.insert(
            "added_at".to_string(),
            Attribute {
                value: json!(i.added_at),
                op: Some(OpCode::IgnoreIfExists),
            },
        );
        map.insert(
            "updated_at".to_string(),
            Attribute {
                value: json!(i.added_at),
                op: Some(OpCode::Max),
            },
        );

        IdentityAttribute(map)
    }
}

impl Default for Identity {
    fn default() -> Self {
        Self {
            uuid: Default::default(),
            platform: Platform::Twitter,
            identity: Default::default(),
            display_name: Default::default(),
            profile_url: None,
            avatar_url: None,
            created_at: None,
            added_at: naive_now(),
            updated_at: naive_now(),
        }
    }
}

impl PartialEq for Identity {
    fn eq(&self, other: &Self) -> bool {
        self.uuid.is_some() && other.uuid.is_some() && self.uuid == other.uuid
    }
}

impl Identity {}
